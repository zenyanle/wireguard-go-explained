
### 核心逻辑：Device 的启动与并发模型

`wgTurnOn` 最终调用了 `NewDevice`，这是协议状态机的起点。

```go
func NewDevice(tunDevice tun.Device, bind conn.Bind, logger *Logger) *Device {
    device := new(Device)
    // ... 初始化状态、MTU、限速器 ...

    // 1. 创建核心队列（Go Channel）
    device.queue.handshake = newHandshakeQueue()
    device.queue.encryption = newOutboundQueue() // 出站加密队列
    device.queue.decryption = newInboundQueue()  // 入站解密队列

    // 2. 启动 Worker Pool
    cpus := runtime.NumCPU()
    device.queue.encryption.wg.Add(cpus)
    for i := 0; i < cpus; i++ {
        // 按照 CPU 核心数启动加密、解密、握手协程
        // 充分利用多核优势处理计算密集型任务
        go device.RoutineEncryption(i + 1)
        go device.RoutineDecryption(i + 1)
        go device.RoutineHandshake(i + 1)
    }

    // 3. 启动 TUN 读取协程
    go device.RoutineReadFromTUN()
    go device.RoutineTUNEventReader()

    return device
}

```

代码中最吸引人的是典型的 **Producer-Consumer（生产者-消费者）** 模型：

- **计算密集型**：加密/解密/握手。根据 CPU 核数开启对应数量的 Goroutine，最大化并行吞吐。
- **IO 密集型**：`RoutineReadFromTUN`，负责源源不断地从虚拟网卡搬运数据。

`WaitGroup` 在这里主要用于优雅退出：保证所有 Worker 处理完手头任务后再销毁 Device。

---

### 出站路径（Outbound）：从 TUN 到 UDP

先看 `RoutineReadFromTUN`，这是流量的源头。

```go
func (device *Device) RoutineReadFromTUN() {
    // ...
    // 内存池优化：预先分配 batch buffer，避免反复 GC
    for i := range elems {
        elems[i] = device.NewOutboundElement()
    }

    offset := MessageTransportHeaderSize // 关键点！

    for {
        // 批量读取（Batch Read），减少系统调用开销
        count, readErr = device.tun.device.Read(bufs, sizes, offset)

        for i := 0; i < count; i++ {
             // ... 查表，根据 IP 找到 Peer ...

             // 将包推送到 Peer 的处理队列
             peer.StagePackets(elemsForPeer)
             peer.SendStagedPackets()
        }
    }
}

```

这里有一个极具深意的细节：`offset := MessageTransportHeaderSize`。
`NewOutboundElement` 分配的内存块中，**预留了头部空间**。读取 TUN 数据时，直接从偏移量之后开始写。这意味着后续加密时，可以**直接在数据包前面填充 WireGuard 协议头，完全实现了 Zero-Copy（零拷贝），无需重新分配内存搬运数据。**

**背压与丢包策略**

`StagePackets` 并没有无脑入队，而是实现了一种**背压（Backpressure）策略**：

```go
func (peer *Peer) StagePackets(elems *QueueOutboundElementsContainer) {
    for {
        select {
        case peer.queue.staged <- elems:
           return
        default:
           // 队列满了？
        }
        select {
        case tooOld := <-peer.queue.staged:
           // 丢弃老包，腾出位置
           peer.device.PutOutboundElement(tooOld)
        default:
        }
    }
}

```

VPN 这种场景下，与其让数据包无限堆积导致延迟过高（Bufferbloat），不如**用丢包换延迟**。既然上层应用如果想要可靠性会用 TCP，这里丢弃老数据包是完全合理的。

**加密核心：RoutineEncryption**

数据包经由 Channel 进入某个 CPU 核心持有的加密协程。

```go
func (device *Device) RoutineEncryption(id int) {
    // ...
    for elemsContainer := range device.queue.encryption.c {
        for _, elem := range elemsContainer.elems {
             // 1. 填充头部 (Type + Receiver + Nonce)
             // 直接在之前预留的 offset 区域写入，零拷贝
             header := elem.buffer[:MessageTransportHeaderSize]
             // ... 写入字段 ...

             // 2. AEAD 加密 + 签名
             elem.packet = elem.keypair.send.Seal(
                 header,     // dst: 密文直接追加在 header 后面
                 nonce[:],   // nonce
                 elem.packet,// plaintext
                 nil,        // ad
             )
        }
        elemsContainer.Unlock() // 解锁，交给发送协程
    }
}

```

这行 `Seal` 代码看似简单，实则暗藏玄机。它直接调用了 ChaCha20-Poly1305 算法。

- **Encapsulation**：它利用了我们在 TUN 读取阶段预留的 `header` 空间，直接将加密后的密文拼接到 header 后面。
- **Authentication**：Poly1305 生成的 Tag 确保了数据包未被篡改。
- **Implicit Verification**：注意 `additionalData` 传了 `nil`。WireGuard 巧妙地通过 Header 里的字段（Receiver Index/Counter）隐式决定了解密所需的 Key 和 Nonce，如果头部被篡改，解密自然会失败，无需显式的 AD 校验，这也是一种微小的性能压榨。

加密完成后，`RoutineSequentialSender` 负责将这一批加密好的 UDP 包通过 socket 发送出去。
