### 入站路径（Inbound）：从 UDP 到 TUN

反向路径主要由 `RoutineReceiveIncoming` 负责。它的核心职责是：**从 UDP Socket 批量读取 -\> 协议分流 -\> 扔给解密协程。**

```go
func (device *Device) RoutineReceiveIncoming(maxBatchSize int, recv conn.ReceiveFunc) {
    // ...
    for {
       count, err = recv(bufs, sizes, endpoints)IP 包会被写入 TUN 设备，操作系统内核接收到包，路由给你的 AP
       // ...
       // 自旋锁逻辑：应对网络抖动导致的连续读取错误
       if deathSpiral < 10 { deathSpiral++; ... }

       for i, size := range sizes[:count] {
           // ... 区分 msgType ...
           switch msgType {
           case MessageTransportType: // 数据包
               // 检查 Key 强时效性
               if keypair.created.Add(RejectAfterTime).Before(time.Now()) {
                   continue // 密钥过期，直接丢弃，防重放/陈旧攻击
               }
               // 入队解密
               peer.queue.inbound.c <- elems
           case MessageInitiationType: // 握手包
               device.queue.handshake.c <- ...
           }
       }
    }
}

```

这里有几个有趣的细节：

1. **Death Spiral（死亡螺旋）**：这变量名起得很有趣，用于处理 socket 异常时的自旋重试，防止程序因为临时的网络错误而崩溃。
2. **RejectAfterTime**：WireGuard 的密钥是有**强时效性**的。哪怕包的格式对，只要密钥生成超过一定时间（默认 2 分钟左右），直接丢弃。这强制了频繁的 Rekey（密钥轮转），极大地提高了安全性。

**解密：RoutineDecryption**

解密协程简直就是加密协程的镜像：

```go
func (device *Device) RoutineDecryption(id int) {
    // ...
    for elemsContainer := range device.queue.decryption.c {
        for _, elem := range elemsContainer.elems {
             // ChaCha20-Poly1305 Open 操作
             // 验证 Tag，解密数据，原地还原出 IP 包
             elem.packet, err = elem.keypair.receive.Open(...)
        }
        elemsContainer.Unlock()
    }
}

```

解密成功后，还原出的 IP 包会被写入 TUN 设备，操作系统内核接收到包，路由给你的 APP。至此，一个完整的 Round-Trip 完成。

### 总结

通读 `wireguard-go` 源码，最大的感受是**克制与高效**。

- 它没有为了跨平台搞复杂的抽象，而是针对 Android 直接利用系统原生接口。
- 它利用 Go 的 GMP 模型完美处理了 CPU 密集型的加解密任务。
- 它通过 Channel 实现了优雅的流水线处理和背压控制。
- 它在内存管理上做到了极致（零拷贝、Sync.Pool），在用户态实现了逼近内核态的性能。
