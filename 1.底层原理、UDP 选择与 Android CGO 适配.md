### TUN 的前置原理

TUN 本质上是一个虚拟网络设备，工作在操作系统的网络层（Layer 3）。它在内核和用户空间程序之间充当了一条“管道”，传递的是完整的 **IP 数据包**。

**发包流程（Outbound）：**

1. 应用程序发出一个 IP 包。
2. 内核根据路由表，判断该包应由 TUN 设备处理，于是将其写入 TUN 设备。
3. 用户空间程序（如 WireGuard）通过文件描述符（fd）读取 TUN 设备，拿到这个 IP 包。
4. 程序对 IP 包进行加密，封装进 UDP 包中。
5. 程序通过标准 UDP Socket 将包发回内核，目标是互联网上的对端。
6. 内核视其为普通 UDP 流量，查主路由表，通过物理网卡发出。

**收包流程（Inbound）：**

1. 物理网卡收到一个 UDP 包，内核根据端口交给用户空间程序。
2. 程序解密，还原出内部的 IP 包。
3. 程序将还原的 IP 包写回 TUN 设备的 fd。
4. 内核从 TUN 设备“收到”这个 IP 包，查询路由表，将其转发给本地目标应用程序。

### 为什么 WireGuard 选择封装在 UDP 中？

WireGuard 的设计哲学是极简与高性能，选择 UDP 主要基于以下考量：

1. **避免 TCP Meltdown（性能灾难）**：TCP over TCP 是经典的隧道反模式。当外层 TCP 发生丢包重传时，内层 TCP 也会触发重传机制，这种双重重传叠加会导致延迟指数级爆炸（详见 [TCP over TCP](https://web.archive.org/web/20230228035749/http://sites.inka.de/~W1011/devel/tcp-tcp.html)）。
2. **无状态漫游（Roaming）**：移动网络环境下，设备 IP 频繁切换（如 Wi-Fi 切 4G）。WireGuard 追求无状态连接，只要收到对端持有正确私钥签名的包，就自动更新对端 Endpoint。如果是 TCP，每次切换 IP 都得重新握手重建状态机，体验极差。
3. **协议开销**：UDP 头部极轻，无连接状态，非常适合作为加密隧道的载体。

---

### 移动端的特殊性与 CGO 桥接

由于 TAP 工作在二层，而 TUN 工作在三层，WireGuard 主要使用 TUN。本文重点探究 `wireguard-go` 在移动端的运作模型（以 Android 为例）。

### **前置原理**

TUN 本质上是一个虚拟网络设备，工作在操作系统的网络层（Layer 3）。它在内核和用户空间程序之间充当了一条“管道”，传递的是完整的 **IP 数据包**。

**发包流程（Outbound）：**

应用程序发出一个 IP 包。

内核根据路由表，判断该包应由 TUN 设备处理，于是将其写入 TUN 设备。

用户空间程序（如 WireGuard）通过文件

由于移动端严格的沙箱权限模型，普通进程无法直接创建虚拟网卡。App 必须通过 Android VpnService 原生代码（Java/Kotlin）走完权限流程，申请到一个虚拟网卡的 fd（文件描述符），再转交给 Go 层。

```go
// CreateUnmonitoredTUNFromFD 将系统 fd 包装为 Go 里的 Device 接口
func CreateUnmonitoredTUNFromFD(fd int) (Device, string, error) {
    err := unix.SetNonblock(fd, true) // 设置非阻塞，关键
    if err != nil {
       return nil, "", err
    }
    file := os.NewFile(uintptr(fd), "/dev/tun")
    tun := &NativeTun{
       tunFile:     file,
       // ... 初始化各类通道和 GRO 表 ...
    }
    // ...
    return tun, name, err
}

```

至此，操作系统提供的原生 fd 被包装成了 `wireguard-go` 内部的 `TUN` 结构体，接管由此开始。

**CGO 的边界艺术**

众所周知，**CGO is not Go**。Go 的 GMP 调度模型与 C 的线程模型天生“八字不合”。笔者原先以为 `wireguard-android` 会将 `wireguard-go` 作为子进程运行以隔离风险，但深入源码发现，它选择以 `c-shared` 模式编译为动态库（.so），通过 C 接口直接调用。

暴露的接口设计得非常克制：

```c
// 简单的桥接层，避免复杂数据结构跨界
extern int wgTurnOn(struct go_string ifname, int tun_fd, struct go_string settings);
extern void wgTurnOff(int handle);
extern int wgGetSocketV4(int handle);
// ...

```

这种设计非常明智：代码简单，不涉及复杂的内存共享，避免了 CGO 常见的指针垂悬问题。

特别值得一看的是 `wgTurnOn` 的实现。它没有返回 Go 结构体的指针（这在 CGO 中是大忌，因为 Go 的栈会移动），而是返回一个 **Handle ID（整数句柄）**：

```go
// 使用全局 Map 管理实例，C 侧只持有 ID
var i int32
for i = 0; i < math.MaxInt32; i++ {
    if _, exists := tunnelHandles[i]; !exists {
        break
    }
}
// ...
tunnelHandles[i] = TunnelHandle{device: device, uapi: uapi}
return i

```

当原生层（Java/Swift）需要操作隧道时，只需传回这个 Handle ID。例如为了防止 VPN 流量回环（Routing Loop），需要保护 UDP Socket 不走 VPN：

```go
//export wgGetSocketV4
func wgGetSocketV4(tunnelHandle int32) int32 {
    handle, ok := tunnelHandles[tunnelHandle]
    // ... 通过 handle 找到 device，再找到 socket fd ...
    return int32(fd)
}

```

在 Java 层：

```java
// 保护 socket 绕过 VPN 网卡，直连物理网卡
service.protect(wgGetSocketV4(currentTunnelHandle));

```

得益于 Go 自带 runtime 和 libc 依赖很少，`wireguard-go` 编译出的库在 Android/iOS 上运行极其丝滑，几乎没有交叉编译的痛苦。
